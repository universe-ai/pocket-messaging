/**
 * The message header is 10 bytes:
 * byte 0:      UInt8 must always be 0. This is the current version of the header which we support.
 * byte 1:      UInt8 length of action (A)
 * byte 2-5:    message ID
 * byte 6-9:    UInt32LE total length of message following from here after the action field (L).
 *
 * The message body follows right afterwards:
 * byte 10+A:   utf8 encoded action
 * byte +L:     N objects
 *
 * After the message initial header, there can be N objects.
 * Each object has its own object header.
 * The total length given in the message header (L) is the sum of all objects including their headers, but not the message header it self.
 *
 * The object header is 4 bytes:
 * byte 0:      UInt8 the data type: see TYPE_ constants for details
 * byte 1:      UInt8 length of key
 * byte 2-3:    UInt16LE length of data
 *
 * The object body follows with key and data:
 * byte 4-x:    utf8 encoded buffer of key
 * byte x-y:    object data
 *
 * Total length given in the message header (L) can then be defined as:
 * L = (number of objects * object header length) + all objects key and data body
 *
 * If an object key is prefixed by the '^' character, then the object is attached to the last decoded object.
 * If there was no previous object then the decoding is aborted.
 */

/**
 * Hash utility is required to generate crytographically strong pseudo-random strings
 * @requires ../util/hash
 */
const Hash = require("../util/hash");

/**
 * Maximum message size in bytes.
 * Disallow messages larger than 1 MiB (total all objects together including all frames).
 * @constant
 * @type {number}
 * @default
*/
const MAX_MESSAGE_SIZE = 1024 * 1024;

/**
 * Maximum object data size in bytes.
 * Disallow objects with data larger than 64 KiB.
 * The full object will maximum be MAX_OBJECT_DATA_SIZE + OBJECT_FRAME_LENGTH + 256;
 * @constant
 * @type {number}
 * @default
*/
const MAX_OBJECT_DATA_SIZE  = 1024 * 64;

// Maximum length of keys, action and message ids. In their binary version.
const KEY_LENGTH = 256;

// type (uint8), action length (uint8), (uint32le) msg id, (uint32le) message length
const MESSAGE_FRAME_LENGTH = 1 + 1 + 4 + 4;

// type (uint8), key length (uint8), data length (uint16)
const OBJECT_FRAME_LENGTH = 1 + 1 + 2;

const TYPE_BINARY       = 0;
const TYPE_BOOLEAN      = 1;
const TYPE_UINT8        = 2;
const TYPE_INT8         = 3;
const TYPE_UINT16       = 4;
const TYPE_INT16        = 5;
const TYPE_UINT32       = 6;
const TYPE_INT32        = 7;
const TYPE_UTF8STRING   = 30;
const TYPE_TEXTNUMBER   = 31;
const TYPE_JSON         = 32;

/** Floats and very large integers are represented in their textual form */

class MessageEncoder
{
    /**
     * Create a new message.
     * @param {string} messageAction maximum 256 bytes action string. Used for routing at receiving end.
     *  If set to existing msgId on receiver's end then it is a reply message.
     * @param {string} [messageId] maximum 16 bytes message ID in hex format.
     */
    constructor(messageAction, messageId)
    {
        this.messageAction = Buffer.from(messageAction, "utf8");
        if (this.messageAction.length > KEY_LENGTH) {
            throw `Message action cannot exceed ${KEY_LENGTH} bytes.`;
        }

        messageId = messageId || Hash.generateRandomHex(4);

        if (messageId.toLowerCase() !== messageId) {
            throw "Message ID must be provided as lowercase hex string.";
        }

        this.messageId = Buffer.from(messageId, "hex");

        if (this.messageId.length !== 4) {
            throw `Message id must be 4 bytes as a hexadecimal string.`;
        }

        this.buffers = [];
    }

    /**
     * Return the hex message ID set in the constructor or auto generated by the constructor.
     * @return {string} message ID in hex format
     */
    getMsgId()
    {
        return this.messageId.toString("hex");
    }

    /**
     * Add any serializable value, including null.
     * Do not put any other data types than the null, number, boolean, array and object.
     * Arrays must also only include fundamental data types.
     * Objects can have attached Buffers, same principle as when calling addObject().
     *
     * @param {string} key prefix key with a "^" to put it on the previously added object as an attribute rather than on the top object.
     * @param {any} any fundamental data type and also Buffer
     */
    add(key, any)
    {
        if (any === undefined) {
            return;
        }

        if (any === null || typeof any === "string") {
            this.addString(key, any);
        }
        else if (typeof any === "number") {
            this.addNumber(key, any);
        }
        else if (typeof any === "boolean") {
            this.addBoolean(key, any);
        }
        else if (Array.isArray(any)) {
            this.addArray(key, any);
        }
        else if (any instanceof Buffer) {
            this.addBinary(key, any);
        }
        else if (typeof any === "object") {
            this.addObject(key, any);
        }
        else {
            throw "Could not add object, only fundamental data types allowed.";
        }
    }

    addBinary(key, buffer)
    {
        if (typeof key !== "string") {
            throw "Key must be string";
        }

        if (buffer === undefined || buffer === null) {
            return;
        }

        if (!(buffer instanceof Buffer)) {
            throw "Expecting Buffer"
        }

        const objectHeader = this._createObjectHeader(TYPE_BINARY, buffer.length, key);
        this.buffers.push(objectHeader);
        this.buffers.push(buffer);
    }

    /**
     * @param {string} utf8 string
     */
    addString(key, string)
    {
        if (typeof key !== "string") {
            throw "Key must be string";
        }

        if (string === undefined || string === null) {
            return;
        }

        if (typeof string === "string") {
            // Pass through
        }
        else {
            throw "Expecting string";
        }

        const buffer = Buffer.from(string, "utf8");
        const objectHeader = this._createObjectHeader(TYPE_UTF8STRING, buffer.length, key);
        this.buffers.push(objectHeader);
        this.buffers.push(buffer);
    }

    addNumber(key, number)
    {
        if (typeof key !== "string") {
            throw "Key must be string";
        }

        if (number === undefined || number === null) {
            return;
        }

        if (typeof number === "number") {
            // Pass through
        }
        else {
            throw "Expecting number";
        }

        const [type, buffer] = this._packNumber(number);
        const objectHeader = this._createObjectHeader(type, buffer.length, key);
        this.buffers.push(objectHeader);
        this.buffers.push(buffer);
    }

    addBoolean(key, boolean)
    {
        if (typeof key !== "string") {
            throw "Key must be string";
        }

        if (boolean === undefined || boolean === null) {
            return;
        }

        if (typeof boolean === "boolean") {
            // Pass through
        }
        else {
            throw "Expecting boolean";
        }

        const buffer = Buffer.alloc(1);
        buffer.writeUInt8(boolean ? 1 : 0);
        const objectHeader = this._createObjectHeader(TYPE_BOOLEAN, buffer.length, key);
        this.buffers.push(objectHeader);
        this.buffers.push(buffer);
    }

    addArray(key, array)
    {
        if (typeof key !== "string") {
            throw "Key must be string";
        }

        if (array === undefined || array === null) {
            return;
        }

        if (Array.isArray(array)) {
            // Pass through
        }
        else {
            throw "Expecting Array";
        }

        this.addJSON(key, JSON.stringify(array));
    }

    /**
     * Add a object and also extract any Buffer objects and place add them as binaries.
     * NOTE: Only buffer attached directly to object will be parsed, any nested buffers
     * will be missed and serialized in ways which we this class cannot restore, so do not do that.
     */
    addObject(key, object)
    {
        if (typeof key !== "string") {
            throw "Key must be string";
        }

        if (object === undefined || object === null) {
            return;
        }

        if (typeof object === "object" && Array.isArray(object) === false) {
            // Pass through
        }
        else {
            throw "Expecting Object";
        }

        // Filter out the Buffer objects and add them as binaries.
        const buffers = [];
        const object2 = {};
        Object.keys(object).forEach( key => {
            const value = object[key];
            if (value instanceof Buffer) {
                buffers.push([key, value]);
            }
            else {
                object2[key] = value;
            }
        });

        this.addJSON(key, JSON.stringify(object2));

        buffers.forEach( tuple => {
            const [key, buffer] = tuple;
            this.addBinary(`^${key}`, buffer);
        });
    }

    /**
     * This add a complex object which is in the same format as the return when unpacking a message's props.
     *
     * The foreseen use case is to use this function to create a new message from an existing message's data.
     * At the top level of the object arrays will be broken down into separat objects.
     *
     * @param {Object} complex
     */
    addProps(object)
    {
        Object.keys(object).forEach( key => {
            const value = object[key];
            if (Array.isArray(value)) {
                if (value.length === 0) {
                    // Empty array we need to handle like JSON otherwise it won't exist.
                    this.addJSON(key, JSON.stringify([]));
                }
                else {
                    value.forEach( value => {
                        this.add(`${key}[]`, value);
                    });
                }
            }
            else {
                this.add(key, value);
            }
        });
    }

    addJSON(key, json)
    {
        if (typeof key !== "string") {
            throw "Key must be string";
        }

        if (json === undefined || json === null) {
            return;
        }

        if (typeof json === "string") {
            // Pass through
        }
        else if (json instanceof Buffer) {
            // Pass through
        }
        else {
            throw "Expecting json string or buffer";
        }

        const buffer = (typeof json === "string") ? Buffer.from(json, "utf8") : json;
        const objectHeader = this._createObjectHeader(TYPE_JSON, buffer.length, key);
        this.buffers.push(objectHeader);
        this.buffers.push(buffer);
    }

    /**
     * Calculate the length of the packed message (when it is packed).
     * Can be used to limit additions to keep a message within a given size before packing it.
     */
    getCurrentLength()
    {
        let length = 0;
        this.buffers.forEach( buffer => length = length + buffer.length + OBJECT_FRAME_LENGTH + 256);
        length = length + MESSAGE_FRAME_LENGTH + 256;
        return length;
    }

    /**
     * Return the available space left in the message for one added object.
     * Note that the value can be greater then the allowed size for a single object.
     */
    getAvailableLength()
    {
        return MAX_MESSAGE_SIZE - this.getCurrentLength() - OBJECT_FRAME_LENGTH - 256;
    }

    /**
     * Return array of buffers representing the whole message.
     *
     * @return {Array<Buffer>}
     */
    pack()
    {
        const buffers = this.buffers.slice();
        buffers.unshift(this._createMessageHeader());
        return buffers;
    }

    /**
     * Figure out number type and pack it.
     * Large numbers over 32 bit and floats are packed in textual form.
     *
     */
    _packNumber(n)
    {
        let type;
        let buffer;

        const isFloat = n !== Math.floor(n);
        let asTextual = false;
        if (isFloat) {
            // Float we pack as textual
            asTextual = true;
        }
        else if (n >= 0) {
            if (n < (2**8)) {
                type = TYPE_UINT8;
                buffer = Buffer.alloc(1);
                buffer.writeUInt8(n);
            }
            else if (n < (2**16)) {
                type = TYPE_UINT16;
                buffer = Buffer.alloc(2);
                buffer.writeUInt16LE(n);
            }
            else if (n < (2**32)) {
                type = TYPE_UINT32;
                buffer = Buffer.alloc(4);
                buffer.writeUInt32LE(n);
            }
            else {
                // Large number
                // Pack as textual
                asTextual = true;
            }
        }
        else {
            if (n >= -(2**7)) {
                type = TYPE_INT8;
                buffer = Buffer.alloc(1);
                buffer.writeInt8(n);
            }
            else if (n >= -(2**15)) {
                type = TYPE_INT16;
                buffer = Buffer.alloc(2);
                buffer.writeInt16LE(n);
            }
            else if (n >= -(2**31)) {
                type = TYPE_INT32;
                buffer = Buffer.alloc(4);
                buffer.writeInt32LE(n);
            }
            else {
                // Large negative number
                // Pack as textual
                asTextual = true;
            }
        }

        if (asTextual) {
            const nStr = String(n);
            type = TYPE_TEXTNUMBER;
            buffer = Buffer.from(nStr);
        }

        return [type, buffer];
    }

    _createObjectHeader(objectType, length, key)
    {
        if (!key || key == "") {
            throw `Key must be provided.`;
        }
        const keyBuf = Buffer.from(key, "utf8");
        if (!keyBuf || keyBuf.length > KEY_LENGTH) {
            throw `Key must be string of maximum ${KEY_LENGTH} bytes.`;
        }
        if (length > MAX_OBJECT_DATA_SIZE) {
            throw `Too large object data for key ${key}, max size is ${MAX_OBJECT_DATA_SIZE} bytes for object data in a message.`;
        }
        const keyLength = keyBuf.length;
        const objectHeader = Buffer.alloc(OBJECT_FRAME_LENGTH + keyLength);
        let pos = 0;
        objectHeader.writeUInt8(objectType, pos);
        pos = pos + 1;
        objectHeader.writeUInt8(keyLength, pos);
        pos = pos + 1;
        objectHeader.writeUInt16LE(length, pos);
        pos = pos + 2;
        keyBuf.copy(objectHeader, pos);

        return objectHeader;
    }

    _createMessageHeader()
    {
        let messageLength = 0;
        this.buffers.forEach( buffer => messageLength = messageLength + buffer.length );

        const actionLength = this.messageAction.length;

        // We deduct the message header so that we can guarantee message is maximum MAX_MESSAGE_SIZE
        if (messageLength > MAX_MESSAGE_SIZE - MESSAGE_FRAME_LENGTH - actionLength) {
            throw `Message onverlow max size of ${MAX_MESSAGE_SIZE} bytes.`;
        }

        const messageHeader = Buffer.alloc(MESSAGE_FRAME_LENGTH + actionLength);
        let pos = 0;
        messageHeader.writeUInt8(0, pos);
        pos = pos + 1;
        messageHeader.writeUInt8(actionLength, pos);
        pos = pos + 1;
        this.messageId.copy(messageHeader, pos);
        pos = pos + 4;
        messageHeader.writeUInt32LE(messageLength, pos);
        pos = pos + 4;
        this.messageAction.copy(messageHeader, pos);
        pos = pos + actionLength;

        return messageHeader;
    }
}

class MessageDecoder
{
    /**
     * @param {Array<Buffer>} buffers
     *
     */
    constructor(buffers)
    {
        this.buffers = buffers;
        this.position = 0;
        this.messageId = null;
        this.action = null;
        this.length = null;
    }

    /**
     * Initialize the unpacking of the message.
     * Tries to decode the initial message header.
     * If the init fails, try again when more data has arrived.
     *
     * @return {boolean} true if successful.
     */
    init()
    {
        if (this.length != null) {
            throw "Cannot run init() more than once when unpacking.";
        }

        const buffer = this._readData(this.position, MESSAGE_FRAME_LENGTH);
        if (!buffer) {
            return false;
        }

        let pos = 0;

        if (buffer.readUInt8(pos) !== 0) {
            // First byte must be zero, this dictates our current formatting version of a message.
            return false;
        }
        pos = pos + 1;
        const actionLength = buffer.readUInt8(pos);
        pos = pos + 1;
        this.messageId = buffer.slice(pos, pos + 4);
        pos = pos + 4;
        this.length = buffer.readUInt32LE(pos);
        pos = pos + 4;

        const actionBuffer = this._readData(this.position + pos, actionLength);
        if (!actionBuffer) {
            return false;
        }

        this.action = actionBuffer.toString("utf8");
        pos = pos + actionLength;

        this.position = this.position + pos;

        return true;
    }

    /**
     * Check if we have a full message in the buffers.
     * @return {boolean} true if there is a full message to be decoded.
     */
    isReady()
    {
        if (this.length == null) {
            throw "Cannot run isReady() before init() has successfully been called.";
        }

        return this.getLength() <= this._getRemainingLength();
    }

    /**
     * Unpack a full message from the buffers.
     * Depends on that init() has been called first and that all the message data is in the buffers.
     *
     * @return {Array<{string} action, {string} messageId, {Object} props>}
     *  action is the given action or the message ID if the message is a reply message.
     *  messageId Is the message's ID.
     *
     */
    unpack()
    {
        if (this.isReady() === false) {
            return null;
        }

        let lastObject = null;
        let props = {};
        const startPos = this.position;
        try {
            while (this.position - startPos < this.getLength() && this._hasNext()) {
                const [type, key1, buffer] = this._next();
                const target = key1.startsWith("^") ? lastObject : props;

                if (!target) {
                    throw `Key ${key1} is pointing to last object, but there is no last object.`;
                }

                const key = key1.startsWith("^") ? key1.slice(1) : key1;

                let object;
                if (type === TYPE_BINARY) {
                    object = buffer;
                }
                else if (type === TYPE_UTF8STRING) {
                    object = buffer.toString("utf8");
                }
                else if (type === TYPE_BOOLEAN) {
                    object = buffer.readUInt8() === 0 ? false : true;
                }
                else if (type === TYPE_INT8) {
                    object = buffer.readInt8();
                }
                else if (type === TYPE_UINT8) {
                    object = buffer.readUInt8();
                }
                else if (type === TYPE_INT16) {
                    object = buffer.readInt16LE();
                }
                else if (type === TYPE_UINT16) {
                    object = buffer.readUInt16LE();
                }
                else if (type === TYPE_INT32) {
                    object = buffer.readInt32LE();
                }
                else if (type === TYPE_UINT32) {
                    object = buffer.readUInt32LE();
                }
                else if (type === TYPE_TEXTNUMBER) {
                    object = Number(buffer.toString());
                }
                else if (type === TYPE_JSON) {
                    try {
                        object = JSON.parse(buffer);
                    }
                    catch(e) {
                        throw "Cannot parse JSON data.";
                    }
                    if (object && typeof object === "object" && Array.isArray(object) === false) {
                        lastObject = object;
                    }
                }
                else {
                    // Unknown type.
                    // Could be that the other end has other types it can encode to, such as BSON, etc.
                    throw "Unknown data type";
                }

                if (key.endsWith("[]")) {
                    const key2 = key.slice(0, -2);
                    const list = target[key2] || [];
                    target[key2] = list;
                    list.push(object);
                }
                else {
                    target[key] = object;
                }
            }
        }
        catch (e) {
            console.error("Could not unpack message:", e);
            props = null;
        }

        this._drain();

        if (props) {
            return [this._getAction(), this._getId(), props];
        }
        return null;
    }

    /**
     * Return the total length of the buffers in the array.
     */
    _getBuffersLength()
    {
        let count = 0;
        this.buffers.forEach( buffer => count = count + buffer.length );
        return count;
    }

    /**
     * Get the length which is remaining in the buffers after the current position.
     */
    _getRemainingLength()
    {
        return this._getBuffersLength() - this.position;
    }

    /**
     * Read data from the buffers.
     */
    _readData(position, length)
    {
        let ret = Buffer.alloc(0);
        let bytesToRead = length;
        let index = 0;
        while (bytesToRead > 0) {
            const buffer = this.buffers[index];
            if (!buffer) {
                return null;
            }
            if (position >= buffer.length) {
                position = position - buffer.length;
                index++;
                continue;
            }
            const l = Math.min(bytesToRead, buffer.length - position);
            ret = Buffer.concat([ret, buffer.slice(position, position + l)]);
            position = 0;
            bytesToRead -= l;
            index++;
        }
        if (ret.length < length) {
            return null;
        }
        return ret;
    }

    /**
     * Return the next object in the message buffers.
     * This function expects there to be data available.
     */
    _next()
    {
        const buffer = this._readData(this.position, OBJECT_FRAME_LENGTH);
        if (!buffer) {
            return null;
        }

        const objectType = buffer.readUInt8();
        let pos = 1;

        const keyLength = buffer.slice(pos, pos + 1).readUInt8();
        pos = pos + 1;

        const objectLength = buffer.slice(pos, pos + 2).readUInt16LE();
        pos = pos + 2;

        const keyBuffer = this._readData(this.position + pos, keyLength);
        if (!keyBuffer) {
            return null;
        }

        const key = keyBuffer.toString("utf8");
        pos = pos + keyLength;

        this.position = this.position + pos;

        const data = this._readData(this.position, objectLength);
        this.position = this.position + objectLength;
        return [objectType, key, data];
    }

    /**
     * Check if we have a full object to be decoded.
     *
     * @return {boolean}
     */
    _hasNext()
    {
        const buffer = this._readData(this.position, OBJECT_FRAME_LENGTH);
        if (!buffer) {
            return false;
        }
        const keyLength = buffer.slice(1, 2).readUInt8();
        const objectLength = buffer.slice(2, 4).readUInt16LE();
        const diff = this._getRemainingLength() - (keyLength + objectLength + OBJECT_FRAME_LENGTH);
        return diff >= 0;
    }

    /**
     * Return the action of the message header.
     * @return {string}
     */
    _getAction()
    {
        return this.action;
    }

    /**
     * Return the message id of the message header in hex format.
     * @return {string}
     */
    _getId()
    {
        return this.messageId.toString("hex");
    }

    /**
     * Return the message length given in the message header.
     * @return {number}
     */
    getLength()
    {
        return this.length;
    }

    /**
     * Drain from the buffers up til the current position and reset the position.
     */
    _drain()
    {
        let bytesToDrain = this.position;
        while (bytesToDrain > 0) {
            const l = this.buffers[0].length;
            if (bytesToDrain >= l) {
                this.buffers.shift();
                bytesToDrain -= l;
                continue;
            }
            this.buffers[0] = this.buffers[0].slice(bytesToDrain);
            bytesToDrain = 0;
        }
        this.position = 0;
    }
}

module.exports = {MessageEncoder, MessageDecoder};
